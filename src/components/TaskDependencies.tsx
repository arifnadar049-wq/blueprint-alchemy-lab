import React, { useState, useEffect } from 'react';
import { Link, Unlink, AlertTriangle, CheckCircle, Clock, Search } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Badge } from '@/components/ui/badge';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger } from '@/components/ui/dialog';
import { Command, CommandEmpty, CommandGroup, CommandInput, CommandItem } from '@/components/ui/command';
import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { useAppStore } from '@/store/useAppStore';
import { Task, TaskStatus, TaskDependency } from '@/types';
import { useToast } from '@/hooks/use-toast';
import { cn } from '@/lib/utils';

interface TaskDependenciesProps {
  taskId: string;
  trigger?: React.ReactNode;
}

export const TaskDependencies = ({ taskId, trigger }: TaskDependenciesProps) => {
  const [open, setOpen] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');
  const [commandOpen, setCommandOpen] = useState(false);
  
  const { tasks, updateTask } = useAppStore();
  const { toast } = useToast();
  
  const currentTask = tasks.find(t => t.id === taskId);
  const currentDependencies = currentTask?.dependencies || [];
  
  // Tasks that depend on the current task
  const dependentTasks = tasks.filter(task => 
    task.dependencies?.some(dep => dep.dependsOnTaskId === taskId)
  );
  
  // Available tasks for dependencies (excluding self and existing dependencies)
  const availableTasks = tasks.filter(task => 
    task.id !== taskId && 
    !currentDependencies.some(dep => dep.dependsOnTaskId === task.id) &&
    !task.archived &&
    task.status !== TaskStatus.COMPLETED
  );

  // Filtered available tasks based on search
  const filteredAvailableTasks = availableTasks.filter(task =>
    task.title.toLowerCase().includes(searchQuery.toLowerCase()) ||
    task.notes.toLowerCase().includes(searchQuery.toLowerCase())
  );

  if (!currentTask) return null;

  const addDependency = async (dependsOnTaskId: string) => {
    try {
      // Check for circular dependencies
      if (wouldCreateCircularDependency(taskId, dependsOnTaskId)) {
        toast({
          title: "Circular dependency detected",
          description: "This dependency would create a circular reference.",
          variant: "destructive"
        });
        return;
      }

      const newDependency: TaskDependency = {
        id: Date.now().toString(), // In real app, this would be generated by the backend
        taskId,
        dependsOnTaskId,
        createdAt: new Date()
      };

      const updatedDependencies = [...currentDependencies, newDependency];
      
      await updateTask(taskId, {
        dependencies: updatedDependencies
      });

      const dependentTask = tasks.find(t => t.id === dependsOnTaskId);
      toast({
        title: "Dependency added",
        description: `"${currentTask.title}" now depends on "${dependentTask?.title}"`,
      });

      setSearchQuery('');
      setCommandOpen(false);
    } catch (error) {
      toast({
        title: "Error",
        description: "Failed to add dependency. Please try again.",
        variant: "destructive"
      });
    }
  };

  const removeDependency = async (dependencyId: string) => {
    try {
      const updatedDependencies = currentDependencies.filter(dep => dep.id !== dependencyId);
      
      await updateTask(taskId, {
        dependencies: updatedDependencies
      });

      toast({
        title: "Dependency removed",
        description: "Task dependency has been removed",
      });
    } catch (error) {
      toast({
        title: "Error", 
        description: "Failed to remove dependency. Please try again.",
        variant: "destructive"
      });
    }
  };

  // Simple circular dependency check
  const wouldCreateCircularDependency = (taskId: string, dependsOnTaskId: string): boolean => {
    const visited = new Set<string>();
    
    const checkCircular = (currentTaskId: string): boolean => {
      if (visited.has(currentTaskId)) return true;
      if (currentTaskId === taskId) return true;
      
      visited.add(currentTaskId);
      
      const task = tasks.find(t => t.id === currentTaskId);
      if (!task) return false;
      
      for (const dep of task.dependencies || []) {
        if (checkCircular(dep.dependsOnTaskId)) return true;
      }
      
      return false;
    };
    
    return checkCircular(dependsOnTaskId);
  };

  const getTaskStatus = (task: Task) => {
    switch (task.status) {
      case TaskStatus.COMPLETED:
        return { icon: CheckCircle, color: 'text-success', bg: 'bg-success/10' };
      case TaskStatus.IN_PROGRESS:
        return { icon: Clock, color: 'text-focus-active', bg: 'bg-focus-active/10' };
      default:
        return { icon: Clock, color: 'text-muted-foreground', bg: 'bg-muted/50' };
    }
  };

  const canStartTask = currentDependencies.every(dep => {
    const dependentTask = tasks.find(t => t.id === dep.dependsOnTaskId);
    return dependentTask?.status === TaskStatus.COMPLETED;
  });

  const blockedDependencies = currentDependencies.filter(dep => {
    const dependentTask = tasks.find(t => t.id === dep.dependsOnTaskId);
    return dependentTask?.status !== TaskStatus.COMPLETED;
  });

  return (
    <Dialog open={open} onOpenChange={setOpen}>
      <DialogTrigger asChild>
        {trigger || (
          <Button variant="outline" className="gap-2">
            <Link className="h-4 w-4" />
            Dependencies
            {currentDependencies.length > 0 && (
              <Badge variant="secondary" className="ml-1">
                {currentDependencies.length}
              </Badge>
            )}
          </Button>
        )}
      </DialogTrigger>
      <DialogContent className="sm:max-w-[600px]">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <Link className="h-5 w-5" />
            Task Dependencies
          </DialogTitle>
        </DialogHeader>
        
        <div className="space-y-6">
          {/* Current Task Status */}
          <div className="flex items-center gap-3 p-3 bg-muted/50 rounded-lg">
            <div className="font-medium text-sm">Current Task:</div>
            <div className="font-medium">{currentTask.title}</div>
            {!canStartTask && (
              <Badge variant="secondary" className="gap-1">
                <AlertTriangle className="h-3 w-3" />
                Blocked
              </Badge>
            )}
          </div>

          {/* Blocking Dependencies */}
          {blockedDependencies.length > 0 && (
            <Alert>
              <AlertTriangle className="h-4 w-4" />
              <AlertDescription>
                This task is blocked by {blockedDependencies.length} incomplete dependenc{blockedDependencies.length === 1 ? 'y' : 'ies'}.
                Complete the dependencies below to unblock this task.
              </AlertDescription>
            </Alert>
          )}

          {/* Add New Dependency */}
          <div className="space-y-3">
            <div className="flex items-center justify-between">
              <h4 className="text-sm font-medium">Add Dependency</h4>
              <Popover open={commandOpen} onOpenChange={setCommandOpen}>
                <PopoverTrigger asChild>
                  <Button variant="outline" size="sm" className="gap-2">
                    <Search className="h-4 w-4" />
                    Add Dependency
                  </Button>
                </PopoverTrigger>
                <PopoverContent className="w-80 p-0">
                  <Command>
                    <CommandInput 
                      placeholder="Search for tasks..." 
                      value={searchQuery}
                      onValueChange={setSearchQuery}
                    />
                    <CommandEmpty>No tasks found.</CommandEmpty>
                    <CommandGroup className="max-h-48 overflow-y-auto">
                      {filteredAvailableTasks.map((task) => {
                        const status = getTaskStatus(task);
                        const StatusIcon = status.icon;
                        
                        return (
                          <CommandItem
                            key={task.id}
                            onSelect={() => addDependency(task.id)}
                            className="flex items-center gap-3 p-2"
                          >
                            <div className={cn("p-1 rounded", status.bg)}>
                              <StatusIcon className={cn("h-3 w-3", status.color)} />
                            </div>
                            <div className="flex-1 min-w-0">
                              <div className="font-medium text-sm truncate">{task.title}</div>
                              <div className="text-xs text-muted-foreground">
                                {task.status.replace('_', ' ')}
                              </div>
                            </div>
                          </CommandItem>
                        );
                      })}
                    </CommandGroup>
                  </Command>
                </PopoverContent>
              </Popover>
            </div>
            
            {availableTasks.length === 0 && (
              <p className="text-sm text-muted-foreground">
                No available tasks to add as dependencies.
              </p>
            )}
          </div>

          {/* Current Dependencies */}
          <div className="space-y-3">
            <h4 className="text-sm font-medium">
              Current Dependencies {currentDependencies.length > 0 && `(${currentDependencies.length})`}
            </h4>
            
            {currentDependencies.length === 0 ? (
              <div className="text-center py-6 text-muted-foreground">
                <Link className="h-12 w-12 mx-auto mb-4 opacity-50" />
                <p>No dependencies set</p>
                <p className="text-sm">This task can be started immediately</p>
              </div>
            ) : (
              <div className="space-y-2">
                {currentDependencies.map((dependency) => {
                  const dependentTask = tasks.find(t => t.id === dependency.dependsOnTaskId);
                  if (!dependentTask) return null;
                  
                  const status = getTaskStatus(dependentTask);
                  const StatusIcon = status.icon;
                  const isCompleted = dependentTask.status === TaskStatus.COMPLETED;
                  
                  return (
                    <div
                      key={dependency.id}
                      className={cn(
                        "flex items-center gap-3 p-3 border rounded-lg",
                        isCompleted ? "bg-success/5 border-success/20" : "bg-muted/30"
                      )}
                    >
                      <div className={cn("p-1 rounded", status.bg)}>
                        <StatusIcon className={cn("h-4 w-4", status.color)} />
                      </div>
                      
                      <div className="flex-1 min-w-0">
                        <div className="font-medium text-sm">{dependentTask.title}</div>
                        <div className="text-xs text-muted-foreground">
                          Status: {dependentTask.status.replace('_', ' ')}
                          {dependentTask.dueDate && (
                            <> • Due: {dependentTask.dueDate.toLocaleDateString()}</>
                          )}
                        </div>
                      </div>
                      
                      <div className="flex items-center gap-2">
                        {isCompleted && (
                          <Badge variant="secondary" className="text-success">
                            Complete
                          </Badge>
                        )}
                        
                        <Button
                          variant="ghost"
                          size="sm"
                          onClick={() => removeDependency(dependency.id)}
                          className="h-8 w-8 p-0 text-muted-foreground hover:text-destructive"
                        >
                          <Unlink className="h-4 w-4" />
                        </Button>
                      </div>
                    </div>
                  );
                })}
              </div>
            )}
          </div>

          {/* Tasks That Depend On This One */}
          {dependentTasks.length > 0 && (
            <div className="space-y-3">
              <h4 className="text-sm font-medium">
                Tasks Waiting On This One ({dependentTasks.length})
              </h4>
              <div className="space-y-2">
                {dependentTasks.map((task) => {
                  const status = getTaskStatus(task);
                  const StatusIcon = status.icon;
                  
                  return (
                    <div
                      key={task.id}
                      className="flex items-center gap-3 p-2 bg-muted/20 rounded-lg"
                    >
                      <div className={cn("p-1 rounded", status.bg)}>
                        <StatusIcon className={cn("h-3 w-3", status.color)} />
                      </div>
                      <div className="flex-1 min-w-0">
                        <div className="text-sm font-medium">{task.title}</div>
                        <div className="text-xs text-muted-foreground">
                          Will be unblocked when this task is completed
                        </div>
                      </div>
                    </div>
                  );
                })}
              </div>
            </div>
          )}
          
          <div className="flex justify-end">
            <Button onClick={() => setOpen(false)}>
              Done
            </Button>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
};